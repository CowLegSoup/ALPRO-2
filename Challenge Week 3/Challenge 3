from collections import deque

def tambah_edge(x,y,adj):
    adj[x].append(y)
    adj[y].append(x)

def cetak_parent(node, adj, parent):
    if parent == 0:
        print("{}-->".format(node))
    else:
        print("{}-->{}".format(node,parent))

    for cur in adj[node]:
        if cur != parent:
            cetak_parent(cur, adj, node) 
    
def cetak_child(akar,adj):
    q = deque()
    q.append(akar)
    visited = [0] * len(adj)
    while q: # BFS
        node = q.popleft()
        visited[node] = 1
        print("{}-->".format(node), end="")
        for cur in adj[node]:
            if visited[cur] == 0 : 
                print(cur, end = " ")
                q.append(cur)
        print()

def cetak_leaf_node(akar, adj):
    for i in range (1,len(adj)):
        if len(adj[i]) == 1 and i != akar:
            print(i, end=" ")

def cetak_derajat(akar, adj):
    for i in range(1, len(adj)):
        print(i, ":", end = " ")
        if i == akar:
            print(len(adj[i]))
        else:
            print(len(adj[i]) - 1)

def tinggi_tree(akar, adj):
    tinggi = 0
    q = deque([(akar,0)])
    visited = [False] * len(adj)
    visited[akar] = True

    while q:
        node, kedalaman = q.popleft()
        tinggi = max(tinggi, kedalaman)
        for tetangga in adj[node]:
            if not visited[tetangga]:
                visited[tetangga] = True
                q.append((tetangga, kedalaman + 1))
    
    return tinggi

def depth_tree(node, adj, target):
    depth = -1
    q = deque([(node, 0)])
    visited = [False] * len(adj)
    visited[node] = True
    while q:
        current, kedalaman = q.popleft()
        if current == target:
            depth = kedalaman
            break
        for tetangga in adj[current]:
            if not visited[tetangga]:
                visited[tetangga] = True
                q.append((tetangga, kedalaman + 1))
    return depth

def diameter_tree(akar, adj):
    diameter = 0
    for i in range (1, len(adj)):
        for j in range (i+1, len(adj)):
            jarak = bfs_jarak(i,j,adj)
            diameter = max(diameter,jarak)
    return diameter

def bfs_jarak(start, end, adj):
    q = deque([(start, 0)])
    visited = [False] * len(adj)
    visited[start] = True
    while q:
        node,jarak = q.popleft()
        if node == end:
            return jarak
        
        for neighbor in adj[node]:
            if not visited[neighbor]:
                visited[neighbor] = True
                q.append((neighbor, jarak + 1))
    return -1

def main():
    N = 9
    akar = 1
    adj = [[] for _ in range(N + 1)]

    tambah_edge(1,2,adj)
    tambah_edge(1,3,adj)
    tambah_edge(1,4,adj)
    tambah_edge(2,5,adj)
    tambah_edge(2,6,adj)
    tambah_edge(2,7,adj)
    tambah_edge(2,8,adj)
    tambah_edge(4,9,adj)

    print("parent dari setiap node adalah:")
    cetak_parent(akar, adj, 0)

    print("\nchild dari setiap node adalah:")
    cetak_child(akar,adj)

    print("\nnode leaf dari tree adalah:")
    cetak_leaf_node(akar, adj)

    print("\nDerajat dari setiap node adalah:")
    cetak_derajat(akar, adj)

    print("\nTinggi tree adalah:", tinggi_tree(akar,adj))

    print("\nDepth tree adalah:", depth_tree(akar,adj,7))

    print("\ndiameter tree adalah:",diameter_tree(akar,adj))

main()
